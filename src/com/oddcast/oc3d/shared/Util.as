package com.oddcast.oc3d.shared{	import com.oddcast.ascom.ObjectFactory;	import com.oddcast.encryption.Base64;	import com.oddcast.oc3d.content.*;	import com.oddcast.oc3d.core.*;	import com.oddcast.oc3d.data.*;		import flash.geom.Vector3D;	import flash.media.Sound;	import flash.net.LocalConnection;	import flash.system.ApplicationDomain;	import flash.utils.ByteArray;	import flash.utils.Dictionary;
		public class Util	{		private static const oc3dMagicNumber_:uint = 0x6f633364;		private static const avtrMagicNumber_:uint = 0x61767472;				public static function queryAvailbleMorphDeformerNames(builder:IAvatarBuilderProxy):Vector.<String>		{			var result:Vector.<String> = new Vector.<String>();			builder.instance().deformationManager().forEachMorphDeformer(function(deformer:IMorphDeformer):void { result.push(deformer.name()); });			return result;		}		public static function playViseme(builder:IAvatarBuilderProxy, sound:Sound, morphDeformerName:String, triggerAudio:Boolean, offset:Number, finishedPlayingCallback:Function=null, failedFn:Function=null):ITalkChannel		{			return builder.instance().talk(sound, morphDeformerName, triggerAudio, offset, function():void			{				if (finishedPlayingCallback != null)					finishedPlayingCallback();							}, failedFn);		}		public static function loadSoundAndPlayVisemeOnAllAvailableMorphDeformers(			builder:IAvatarBuilderProxy, 			url:String, 			triggerAudio:Boolean,			offset:Number,			finishedLoadingCallback:Function=null, // Function<void(Vector.<ITalkChannel>)> 			finishedPlayingCallback:Function=null, // Function<void()>			failedFn:Function=null,			progressedFn:Function=null):void		{			var morphDeformsNames:Vector.<String> = queryAvailbleMorphDeformerNames(builder);						builder.instance().scene().engine().resourceManager().accessSound(url, false, function(sound:Sound):void			{				if (sound.bytesTotal == 0)				{					var err:String = "Warning - invalid zero length mp3 found at url \"" + url + "\"";					trace(err);					if (failedFn != null)						failedFn(err);				}				else				{					if (morphDeformsNames.length > 0)					{						var k:Function = Util.delayN(morphDeformsNames.length, function():void						{							if (finishedPlayingCallback != null)								finishedPlayingCallback();						});						var result:Vector.<ITalkChannel> = new Vector.<ITalkChannel>(morphDeformsNames.length, true);						if (finishedLoadingCallback != null)							finishedLoadingCallback(result);						for (var i:uint=0; i<morphDeformsNames.length; ++i)						{							if (!triggerAudio)								result[i] = playViseme(builder, sound, morphDeformsNames[i], false, offset, k, failedFn);							else								result[i] = playViseme(builder, sound, morphDeformsNames[i], (i==0?true:false), offset, k, failedFn);						}					}					else					{						var result2:Vector.<ITalkChannel> = new Vector.<ITalkChannel>(1, true);						result2[0] = new FakeTalkChannel(sound, triggerAudio, offset, function():void						{							if (finishedPlayingCallback != null)								finishedPlayingCallback();													}, failedFn);						if (finishedLoadingCallback != null)							finishedLoadingCallback(result2);					}				}							}, failedFn, progressedFn);		}				private static const DATA_VERSION:uint = 5;		public static function avatarDataToByteArray(data:AvatarData):ByteArray		{			var version:uint = DATA_VERSION;			var output:ByteArray = new ByteArray();			output.writeUnsignedInt(avtrMagicNumber_);			output.writeByte(version);			DataUtil.Avatar_serialize(output, data, version);			return output;		}		public static function sceneDataToByteArray(data:SceneData):ByteArray		{			var version:uint = DATA_VERSION;			var result:ByteArray = new ByteArray();			result.writeUnsignedInt(oc3dMagicNumber_);			result.writeByte(version);			DataUtil.Scene_serialize(result, data, version);			return result;		}		public static function byteArrayToAvatarData(array:ByteArray):AvatarData		{			var result:AvatarData = new AvatarData();			var magicNumber:uint = array.readUnsignedInt();			if (magicNumber != avtrMagicNumber_)				throw new Error("failed to deserialize avatar data");			var version:int = array.readByte();			if (version > DATA_VERSION)				throw new Error("failed to read avatar data - version " + version + " is too new expected " + DATA_VERSION);			return DataUtil.Avatar_deserialize(array, version);		}		public static function byteArrayToSceneData(array:ByteArray):SceneData		{			var magicNumber:uint = array.readUnsignedInt();			if (magicNumber != oc3dMagicNumber_)				throw new Error("failed to deserialize scene data");			var version:int = array.readByte();			if (version > DATA_VERSION)				throw new Error("failed to read scene data - version " + version + " is too new expected " + DATA_VERSION);			return DataUtil.Scene_deserialize(array, version);		}				private static var scene2as_:IScene2AsPlugIn;		private static var collada2Scene_:ICollada2ScenePlugIn;		private static var avatar2as_:IAvatar2AsPlugIn;		private static var pendingContentRequests_:Vector.<Function>;				public static function sceneToAs(			plugInUrl:String,			data:SceneData,			continuationFn:Function, // Function<string>			failedFn:Function=null, progressedFn:Function=null):void		{			// we must first load up the plugin that handles the conversion...			// during loading, avoid missing requests by stashing them 			// away until the plugin is fully loaded.  			if (scene2as_ == null)			{				if (pendingContentRequests_ == null)				{					pendingContentRequests_ = new Vector.<Function>();					pendingContentRequests_.push(function():void{ sceneToAs(plugInUrl, data, continuationFn, failedFn, progressedFn); });					ObjectFactory.load(plugInUrl, new ApplicationDomain(ApplicationDomain.currentDomain), function(factory:ObjectFactory):void					{						scene2as_ = IScene2AsPlugIn(factory.createObject("IScene2AsPlugIn", 1, []));						for each (var fn:Function in pendingContentRequests_)							fn();						pendingContentRequests_ = null;											}, failedFn, progressedFn);				}				else					pendingContentRequests_.push(function():void{ sceneToAs(plugInUrl, data, continuationFn, failedFn, progressedFn); });			}			else				continuationFn(scene2as_.convert(data));		}				public static function colladaToScene(			plugInUrl:String,			storage:IStorageProvider,			uri:String, 			continuationFn:Function, // Function<SceneData>			failedFn:Function=null, progressedFn:Function=null):void		{			// we must first load up the plugin that handles the conversion...			// during loading, avoid missing requests by stashing them 			// away until the plugin is fully loaded.  			if (collada2Scene_ == null)			{				if (pendingContentRequests_ == null)				{					pendingContentRequests_ = new Vector.<Function>();					pendingContentRequests_.push(function():void{ colladaToScene(plugInUrl, storage, uri, continuationFn, failedFn, progressedFn); });					ObjectFactory.load(plugInUrl, new ApplicationDomain(ApplicationDomain.currentDomain), function(factory:ObjectFactory):void					{						collada2Scene_ = ICollada2ScenePlugIn(factory.createObject("ICollada2ScenePlugIn", 1, []));						for each (var fn:Function in pendingContentRequests_)							fn();						pendingContentRequests_ = null;											}, failedFn, progressedFn);				}				else					pendingContentRequests_.push(function():void{ colladaToScene(plugInUrl, storage, uri, continuationFn, failedFn, progressedFn); });			}			else			{				storage.downloadText(uri, function(d:String):void 				{					if (d == null)					{						continuationFn(null);						return;					}					try					{						var sceneData:SceneData = collada2Scene_.convert(new XML(d));						if (sceneData == null)						{							continuationFn(null);							return;						}							sceneData.Name = Util.rsplit(Util.rsplit(uri, "/")[1], ".")[0];						continuationFn(sceneData);					}					catch (any:Error)					{						trace(any.message);						if (failedFn != null)							failedFn(any.message);					}									}, failedFn, progressedFn);			}		}		public static function avatarToAs(			plugInUrl:String,			data:AvatarData,			continuationFn:Function, // Function<as3:String>			failedFn:Function=null, progressedFn:Function=null):void		{			// we must first load up the plugin that handles the conversion...			// during loading, avoid missing requests by stashing them 			// away until the plugin is fully loaded.  			if (avatar2as_ == null)			{				if (pendingContentRequests_ == null)				{					pendingContentRequests_ = new Vector.<Function>();					pendingContentRequests_.push(function():void{ avatarToAs(plugInUrl, data, continuationFn, failedFn, progressedFn); });					ObjectFactory.load(plugInUrl, new ApplicationDomain(ApplicationDomain.currentDomain), function(factory:ObjectFactory):void					{						avatar2as_ = IAvatar2AsPlugIn(factory.createObject("IAvatar2AsPlugIn", 1, []));						for each (var fn:Function in pendingContentRequests_)							fn();						pendingContentRequests_ = null;											}, failedFn, progressedFn);				}				else					pendingContentRequests_.push(function():void{ avatarToAs(plugInUrl, data, continuationFn, failedFn, progressedFn); });			}			else				continuationFn(avatar2as_.convert(data));		}				public static const BACKSPACE:int = 8;		public static const LEFT:int = 37;		public static const UP:int = 38;		public static const RIGHT:int = 39;		public static const DOWN:int = 40;		public static const DELETE:int = 46;		public static const D0:int = 48;		public static const D1:int = 49;		public static const D2:int = 50;		public static const D3:int = 51;		public static const D4:int = 52;		public static const D5:int = 53;		public static const D6:int = 54;		public static const D7:int = 55;		public static const D8:int = 56;		public static const D9:int = 57;				public static const TILDE:int = 96;		public static const A:int = 97;		public static const B:int = 98;		public static const C:int = 99;		public static const D:int = 100;		public static const E:int = 101;		public static const F:int = 102;		public static const G:int = 103;		public static const H:int = 104;		public static const I:int = 105;		public static const J:int = 106;		public static const K:int = 107;		public static const L:int = 108;		public static const M:int = 109;		public static const N:int = 110;		public static const O:int = 111;		public static const P:int = 112;		public static const Q:int = 113;		public static const R:int = 114;		public static const S:int = 115;		public static const T:int = 116;		public static const U:int = 117;		public static const V:int = 118;		public static const W:int = 119;		public static const X:int = 120;		public static const Y:int = 121;		public static const Z:int = 122;				public static function dedupAndSortIds(ids:Array):Array		{			var tmp:Dictionary = new Dictionary();			for each (var id:int in ids)				tmp[id] = id;			var result:Array = new Array();			for each (var id2:int in tmp)				result.push(id2);			return result.sort(Array.NUMERIC);		}				public static function extractSyncData(id3Comment:String):Array // retVal:Array<SyncDatum>		{			var result:Array = new Array();			if (Util.isNullOrEmpty(id3Comment))				return result;							var phonemes:Array = Util.completeSplit(Util.rsplit(Util.split(id3Comment, "timed_phonemes = \"")[1], "\"")[0], "\t", true);						for each (var phoneme:String in phonemes)			{				var data:SyncDatum = new SyncDatum();				data.extractFromCompressedString(phoneme, .6, 2, 3);				if (data.isPhoneme())					result.push(data);			}						return result;		}				public static function xmlEscape(s:String):String		{			/*return Util.replaceAll(Util.replaceAll(Util.replaceAll(Util.replaceAll(Util.replaceAll(s, 				"&", "&amp;"), 				"'", "&apos;"), 				"\"", "&quote;"),				">", "&gt;"),				"<", "&lt;");*/			return Util.replaceAll(Util.replaceAll(Util.replaceAll(Util.replaceAll(Util.replaceAll(Util.replaceAll(s, 				"&", "&amp;"), 				"'", "&apos;"), 				"\"", "\\\""),				"\\", "\\\\"),				">", "&gt;"),				"<", "&lt;");		}		public static function xmlUnescape(s:String):String		{			/*return Util.replaceAll(Util.replaceAll(Util.replaceAll(Util.replaceAll(Util.replaceAll(s, 				"&lt;", "<"),				"&gt;", ">"),				"&quote;", "\""),				"&apos;", "'"), 				"&amp;", "&"); */			return Util.replaceAll(Util.replaceAll(Util.replaceAll(Util.replaceAll(Util.replaceAll(Util.replaceAll(s, 				"&lt;", "<"),				"&gt;", ">"),				"\\\\", "\\"),				"\\\"", "\""),				"&apos;", "'"), 				"&amp;", "&"); 		}				public static function unescape(s:String):String		{			return Util.replaceAll(Util.replaceAll(Util.replaceAll(Util.replaceAll(Util.replaceAll(Util.replaceAll(s,				   "\\t", "\t"), 				   "\\'", "\'"), 				   "\\r", "\r"), 				   "\\n", "\n"), 				   "\\\"", "\""), 				   "\\\\", "\\");		}		public static function escape(s:String):String		{			return Util.replaceAll(Util.replaceAll(Util.replaceAll(Util.replaceAll(Util.replaceAll(Util.replaceAll(s, 				   "\\", "\\\\"), 				   "\"", "\\\""), 				   "\n", "\\n"), 				   "\r", "\\r"), 				   "\'", "\\'"), 				   "\t", "\\t");		}				public static function mapArrayToStringVector(array:Array):Vector.<String>		{			var result:Vector.<String> = new Vector.<String>(array.length);			for (var i:uint=0; i<array.length; ++i)				result[i] = array[i];			return result;		}				public static function chain(strings:Vector.<String>, charDelimiter:String):String		{			var result:String = "";			for each(var s:String in strings)			{				if (result == "")					result = escape(s);				else					result += charDelimiter + escape(s);			}			return result;					}		public static function unchain(stringChain:String, charDelimiter:String):Array		{			var result:Array = new Array();			if (Util.isNullOrEmpty(stringChain))				return result;							var tup:Array;			while(true)			{				tup = split(stringChain, charDelimiter);				result.push(unescape(tup[0]));								if (tup[1].length == 0)					break;				else					stringChain = tup[1]; 			}			return result;		}				// hack in as3 to initiate the garbage collector		public static function garbageCollect():void		{			try			{				var lc1:LocalConnection = new LocalConnection();				var lc2:LocalConnection = new LocalConnection();								lc1.connect("name");				lc2.connect("name");			}			catch(e:Error) {}		}				public static function isDictionaryEmpty(dict:Dictionary):Boolean		{			for each(var v:Object in dict)				return false;			return true;		}				public static function isNullOrEmpty(string:String):Boolean		{			return string==null || string.length == 0;		}		public static function generateUniqueKeyName(prefix:String, alreadyExistsFn:Function):String //alreadyExistsFn<Boolean(String)> 		{			if (!alreadyExistsFn(prefix)) 				return prefix;			var i:int = 1;						var result:String = null;			var p:String = Util.rsplit(prefix, "-")[0];			if (isNullOrEmpty(p))				p = prefix;			while (result == null)			{				var keyName:String = p + "-" + i;				if (!alreadyExistsFn(keyName))					result = keyName;				++i;			}			return result;		}				public static function split(str:String, pivot:String):Array		{			var index:int = str.indexOf(pivot);			if (index == -1)				return [str, ""];			else				return [str.substr(0, index), str.substr(index + pivot.length, str.length - (index + pivot.length))];		}		public static function rsplit(str:String, pivot:String):Array		{			var index:int = str.lastIndexOf(pivot);			if (index == -1)				return ["", str];			else				return [str.substr(0, index), str.substr(index + pivot.length, str.length - (index + pivot.length))];		}		public static function completeSplit(str:String, delimiter:String, removeNulls:Boolean=true, transformFn:Function=null):Array // Array<String>		{			var result:Array = new Array();			if (str == "")				return result;			do			{				var tup:Array = Util.split(str, delimiter);				if (!removeNulls || (removeNulls && !isNullOrEmpty(tup[0])))					result.push(transformFn == null ? tup[0] : transformFn(tup[0]));				str = tup[1];			}			while (!isNullOrEmpty(str));			return result;		}		public static function contains(str:String, search:String):Boolean		{			if (str == null)				return false;			else				return str.indexOf(search, 0) != -1;		}		// binaryFn:Function<*, *>:Boolean		public static function within(tup:Array, any:*, binaryFn:Function=null):Boolean		{			var len:uint = tup.length;			for (var i:uint=0; i<len; ++i)			{				if (binaryFn == null)				{					if (tup[i] == any)						return true;				}				else				{					if (binaryFn(tup[i], any))						return true;				}			}			return false;		}				public static function replaceAll(s:String, oldStr:String, newStr:String):String		{			var result:String = "";			while (true)			{				var index:int = s.indexOf(oldStr, 0);				if (index == -1)				{					result += s;					return result;				}				else				{					result += s.substr(0, index) + newStr;					s = s.substr(index + oldStr.length);				}			}						return result;		}				public static function forEach(tup:Array, fn:Function):void		{			for (var i:uint=0; i<tup.length; ++i)				fn(tup[i]);		}				public static function mapMatrixData(tup:Vector.<MatrixData>, unaryFn:Function):Vector.<MatrixData>		{			for (var i:uint=0; i<tup.length; ++i)				tup[i] = unaryFn(tup[i]);			return tup;		}		public static function mapString(tup:Vector.<String>, unaryFn:Function):Vector.<String>		{			for (var i:uint=0; i<tup.length; ++i)				tup[i] = unaryFn(tup[i]);			return tup;		}		public static function mapArray(tup:Array, unaryFn:Function):Array		{			for (var i:uint=0; i<tup.length; ++i)				tup[i] = unaryFn(tup[i]);			return tup;		}		public static function map(tup:Vector.<Vector3D>, unaryFn:Function):Vector.<Vector3D>		{			for (var i:uint=0; i<tup.length; ++i)				tup[i] = unaryFn(tup[i]);			return tup;		}		public static function mapCopy(tup:Vector.<Vector3D>, unaryFn:Function):Vector.<Vector3D>		{			var result:Vector.<Vector3D> = new Vector.<Vector3D>(tup.length);			for (var i:uint=0; i<tup.length; ++i)				result[i] = unaryFn(tup[i]);			return result;		}		public static function map2Copy(tup1:Vector.<Vector3D>, tup2:Vector.<Vector3D>, binaryFn:Function):Vector.<Vector3D>		{			var len:uint = Math.min(tup1.length, tup2.length);			var result:Vector.<Vector3D> = new Vector.<Vector3D>(len);			for (var i:uint=0; i<len; ++i)				result[i] = binaryFn(tup1[i], tup2[i]);			return result;		}		public static function map2(tup1:Vector.<Vector3D>, tup2:Vector.<Vector3D>, binaryFn:Function):Vector.<Vector3D>		{			var len:uint = Math.min(tup1.length, tup2.length);			for (var i:uint=0; i<len; ++i)				tup1[i] = binaryFn(tup1[i], tup2[i]);			return tup1;		}		public static function endsWith(str:String, match:String):Boolean		{			if (str.length == 0 && match.length != 0)				return false;			else				return String(rsplit(str, match)[1]).length == 0;		}		public static function startsWith(str:String, match:String):Boolean		{			if (str.length == 0 && match.length != 0)				return false;			else				return String(split(str, match)[0]).length == 0;		}		private static var debugCounter:int = 0;        public static function delayN(n:uint, lambda:Function):Function        {        	//++debugCounter;        	//trace("delayN BEGIN - " + n + " (" + debugCounter + ")");	        if (n == 0)	        {                lambda();                return null;	        }	        else	        {                return (function (i:int, c:int):Function { return function():void                {                    --i;                    if (i == 0)                        lambda();                    else if (i < 0)                    	throw new Error("force underflow");                        //throw new Error("force underflow (" + c + ")");                                                        }; })(n, debugCounter);	        }        }				// forEachWithKFn:Function<void(param:*, k:Function)>		public static function asyncForEach(array:*, forEachWithKFn:Function, continuationFn:Function):void		{			var len:uint = array.length;			if (len == 0)				continuationFn();			else			{				var i:uint = 0;				var nextStepFn:Function = function():void				{					forEachWithKFn(array[i++], function():void					{						if (i >= len)							continuationFn();						else							nextStepFn();					});				};				nextStepFn();			}		}				public static function dictionaryLength(dict:Dictionary):uint		{			var result:uint = 0;			for (var k:String in dict)				++result;			return result;		}				public static function trimNumber(n:Number, factor:Number=1000):Number 		{			//return Number(int(n * 1000000 + .5)) / 1000000; 			return Number(int((n * factor) + .5)) / factor;		}				private static var sameTimestampCounter_:uint;		private static var prevTimestamp_:String;		public static function currentTimestamp():String		{			var date:Date = new Date();			var ts:String = String(date.fullYearUTC) + date.monthUTC + date.dayUTC + date.hoursUTC + date.minutesUTC + date.secondsUTC + date.millisecondsUTC;			if (!Util.isNullOrEmpty(prevTimestamp_))			{				if (ts == prevTimestamp_)					++sameTimestampCounter_;				else					sameTimestampCounter_ = 0;			}			prevTimestamp_ = ts;			if (sameTimestampCounter_ > 0)				return ts + "_" + sameTimestampCounter_;			else				return ts;		}		public static function tryFindThumbnail(parent:INode):IThumbnail		{			var thumbs:Array = parent.children([IThumbnail]);			if (thumbs.length == 0)				return null;			else				return thumbs[0];		}		public static function hasCategory(node:INode, category:ICategoryProxy):Boolean		{			return Util.within(node.parents([ICategoryProxy]), category);		}				public static function hasCategoryString(node:INode, categoryStr:String, exactMatch:Boolean=true):Boolean		{			return Util.within(node.parents([ICategoryProxy]), function(n:ICategoryProxy):Boolean			{				if (exactMatch)					return n.name() == categoryStr;				else					return n.name().indexOf(categoryStr) >= 0; 			} );		}				public static function leaveOneChildAssociation(pnode:INodeProxy, type:Class, continuationFn:Function, failedFn:Function=null, progressedFn:Function=null):void		{			if (pnode.impl() is INode)			{				var node:INode = INode(pnode.impl());				var children:Array = node.children([type]);				var force:Function = Util.delayN(children.length, continuationFn);				for (var ci:uint=1; ci<children.length; ++ci)					INode(node.impl()).builder().removeAssociation(node, children[ci], force, failedFn, progressedFn);			}		}				public static function _tmp_ConvertVectorToArray(v:Object):Array		{			var result:Array = new Array(v.length);			for each (var i:Object in v)				result.push(i);			return result;		}		public static function mayaEscape(name:String):String 		{ 			return Util.replaceAll(Util.replaceAll(Util.replaceAll(Util.replaceAll(name, ":", "__"), "|", "___"), "-", "____"), "2dgen", "twodgen"); 		}		public static function mayaUnescape(name:String):String		{			return Util.replaceAll(Util.replaceAll(Util.replaceAll(Util.replaceAll(name, "twodgen", "2dgen"), "____", "-"), "___", "|"), "__", ":"); 		}		public static function deflate(s:String):String		{			var b:ByteArray = new ByteArray();			b.writeUTF(s);			b.deflate();			return Base64.encode(b);		}				public static function inflate(s:String):String		{			var b:ByteArray = Base64.decode(s);			b.inflate();			return b.toString().substr(2);		}		public static function occrpt(s:String, o:int):String		{													var d:String = new String();								for (var i:int=0; i<s.length; ++i)				{													var c:int = s.charCodeAt(i);									if (c >= 48 && c <= 57)							{													c = (c - o)-48;									if (c < 0) c += (57-48+1);						c = (c % (57-48+1)) + 48;					}												else												if (c >= 65 && c <= 90)								{														c = (c - o)-65;										if (c < 0) c += (90-65+1);							c = (c % (90-65+1)) + 65;						}													else													if (c >= 97 && c <= 122)								{															c = (c - o)-97;											if (c < 0) c += (122-97+1);								c = (c % (122-97+1)) + 97;							}																d += String.fromCharCode(c);				}															return d;									}												public static function flashSort(a:Vector.<Number>):void		{			var n:int = a.length;			var i:int = 0, j:int = 0, k:int = 0, t:int;			var m:int = int(n * .125) + 1;			var l:Vector.<int> = new Vector.<int>(m);			var anmin:Number = a[0];			var nmax:int  = 0;			var nmove:int = 0;						for (i = 1; i < n; ++i)			{				if (a[i] < anmin) anmin = a[i];				if (a[i] > a[nmax]) nmax = i;			}						if (anmin == a[nmax]) return;						var c1:Number = (m - 1) / (a[nmax] - anmin);						for (i = 0; i < n; ++i)			{				k = int(c1*(a[i] - anmin));				++l[k];			}						for (k = 1; k < m; ++k)			{				l[k] += l[int(k-1)];			}						var hold:Number = a[nmax];			a[nmax] = a[0];			a[0] = hold;						var flash:Number;			j = 0;			k = int(m - 1);			i = int(n - 1);						while (nmove < i)			{				while (j > (l[k]-1))				{					k = int(c1 * (a[ int(++j) ] - anmin));				}								flash = a[j];								while (!(j == l[k]))				{					k = int(c1 * (flash - anmin));					hold = a[ (t = int(l[k]-1)) ];					a[ t ] = flash;					flash = hold;					--l[k];					++nmove;				}			}						for(j = 1; j < n; ++j)			{				hold = a[j];				i = int(j - 1);				while(i >= 0 && a[i] > hold)					a[int(i+1)] = a[ int(i--) ];				a[int(i+1)] = hold;			}		}	}}